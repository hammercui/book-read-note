### 1 make与new的差别，引用类型的意义？
new(T) T类型新值分配空间，并赋零值,返回t的地址
make 只能是slice,map,chan 类型，不是零值，也不是指针，是初始化之后的引用。
引用类型函数传递时，可以修改。

new和make分配的内存，不一定都在堆上，如果内存小并且现制定函数帧，经过逃逸分析会分配在栈上，
函数执行完毕就回收。

引用比如map本质还是个struct，而go里没有引用传递，可以通过打印实参与形参的地址确认这一点。
形参与实参的地址是不同的，但是指向的array是同一个，可以直接修改。
而指针类型在传递的过程中，是拷贝这个指针变量，指针变量的地址会变化，但是值是实际物理空间地址，不会变。
在64位操作系统，每次传参拷贝的是指针，8位。


2 逃逸分析？
确认内存分配在栈还是堆上，如果引用的生命周期大于实际值，会分配在堆上，或者超过32k。
golang因为有逃逸分析，所以不会所有的变量都分配在堆上，大大减小了gc的压力，因此可以不用设计分代回收。


3 channel的实现？
### 4 gmp与gc?
常见的gc有四种：
1. 引用计数：优点是回收快，实现简单，不需要stw;缺点是无法解决循环引用问题，对cache不友好，使用典型object-c
2. 标记-清除：mark-sweep。古老但有效，如果不可达先标记，到达阈值再stw进行清除。奠定了大部分gc算法的基础。
3. 节点复制 copying: java也用到了，只要是分代回收，不连续分配，在代划分时都会用到copy
4. 分代回收：比如java。

golang使用三色标记清除法：
1 遍历全局指针和groutine栈指针
2 标记mark过程
    2.1 root开始，默认所有对象为白色，遍历所有可达对象，遍历标记为灰色，放入待处理队列。这个过程可能有新的对象创建，需要写屏障write battier记录。
    2.2 遍历灰色队列，将引用对象标记为灰色，放入待处理队列，自身标记为黑色。
    2.3 重复2.2，直到灰色为空，此时白色为垃圾，回收
3 stw
    3.1 gc开始，打开wirte barrier
    3.2 扫描，如果没有stw，mark也不清。

[Golang 垃圾回收剖析](http://legendtkl.com/2017/04/28/golang-gc/)

### 5 网络io等待队列？
> io input,output,输入输出，信息交换的流程。
五种io模型：
* 阻塞io(BIO):应用进程向内核发起recfrom请求数据，准备数据报，进程阻塞，从内核复制数据到进程，解除阻塞。
* 非阻塞io(NIO):应用向内核recfrom申请时，缓冲区没有数据，直接返回应用，应用不断尝试。
* io复用模型()：进程将多个fd传递给select，阻塞，等待fd就绪；就绪后通知进程调用recfrom函数，读取数据。核心是一个线程监控多个fd,减少线程分配。
    可同时监控多个fd的函数，就是slect,poll,epoll函数。
    两类线程职能：
    询问线程：select函数监控fd是否有数据
    receiver线程： 询问线程通知去tcp缓冲区拉取数据
* 信号驱动模型：由主动轮询换为被动接受信号，减少大量无效轮询。
* 异步io: 发起read请求，由tcp缓冲区从内核态拷贝入用户态，通知应用线程。异步io天生就是非阻塞的，因为发起read请求后直接就返回了，不会阻塞后续指令。

#### 5.1 在论同步与异步的区别
>内核处理网络数据包有两个阶段，step1 内核空间socket接收缓冲区，这叫数据准备阶段 step2 内核空间拷贝到用户空间，应用读取数据，这叫数据拷贝阶段。

阻塞与非阻塞的区别在于第一阶段，应用询问缓冲区，缓冲区为空时是直接返回还是等待。
而异步与同步的区别在于第二阶段，用户线程执行数据拷贝，成功后返回；还是直接拷贝，完成之后再通知用户线程。

Linux下的 epoll和Mac 下的 kqueue都属于同步 IO。
非阻塞函数：
select: 内核态完成轮询，只能支撑小于1000个并发连接
poll: 改进型的select,只是改进了select只能监听1024个文件描述符的数量限制，但是并没有在性能方面做出改进
epoll： 改进型的poll,epoll只是返回IO活跃的Socket连接。用户进程可以直接进行IO操作。不需要接受socket文件描述符，避免用户空间内核空间的来回复制。
参考：
* [epoll nio区别_一篇文章带你彻底搞懂NIO](https://blog.csdn.net/weixin_39888943/article/details/112014207)
* [通俗理解BIO NIO select epoll并图解举例](https://cloud.tencent.com/developer/article/1773847)
* [bio,nio,aio的区别 select,poll,epoll的区别](https://www.cnblogs.com/eryun/p/12040508.html)
* [深入理解NIO select&epoll](https://zhuanlan.zhihu.com/p/150635981)
* [100%弄明白5种IO模型]([100%弄明白5种IO模型](https://zhuanlan.zhihu.com/p/115912936))
* [5种网络IO模型](https://zhuanlan.zhihu.com/p/54580385)

### 6 读写屏障



#### 6.1 写屏障 write barrier
用户程序并发执行垃圾回收算法那，程序会一致修改内存，要记录下来。

### 7 map的实现，sync.map的实现，map实现随机的方法

大部分在《go语言设计与实现里》


### 8 并发actor模型与csp（Communicating Sequential Processes）
>相同点都是通过消息传递来共享内存，并不会产生数据竞争。

* 每个actor都携带mailbox,负责消息传递，隔离了方法调用。actor自己维护状态，规避了锁和线程问题。
* actor需要借助强大的路由系统，实现分布式。
* 容错机制，因为每个actor物理隔离，不需要防御式编程，任其崩溃。

缺点：
* actor分散问题，分散在多个宿主，怎么处理集合
* 缓存问题，每个actor都有自己的状态，如何销毁，怎么知道是否已销毁。
* 分布式问题：分布式一致性
* mailbox堆积问题

适用场景：
* rpc,actor位置透明化
* 单线程异步，资源竞争类，比如秒杀
* 负载均衡，动态扩容

### 9 栈帧 帧边界frame boundaries

函数调用后，并没必要立即清理栈空间，再次函数调用时，内存被再次用到，初始化的时候，接受新的拷贝值，清理旧值。
所有的变量至少会被初始化为相应类型的零值。

但是使用的指针，就意味着共享，或者叫间接访问内存了。